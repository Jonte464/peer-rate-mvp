// prisma/schema.prisma 
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * Kunder/användare (registrera dig-formuläret)
 */
model Customer {
  id             String   @id @default(uuid())
  subjectRef     String   @unique        // används som "konto-id", vi sätter detta = email (lowercase)
  fullName       String?
  personalNumber String?  @unique
  email          String?  @unique
  phone          String?
  addressStreet  String?
  addressZip     String?
  addressCity    String?
  country        String?

  // NYTT: lösenord (hashat, aldrig klartext)
  passwordHash   String?

  // NYTT: samtycke till inhämtning från tredje part
  thirdPartyConsent Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  ratings       Rating[]
  reports       Report[]      @relation("CustomerReports")
  score         Score?
  transactions  Transaction[]
  termsAccepted Boolean @default(false)

  // NYTT: externa profiler (Blocket, Tradera m.fl.)
  externalProfiles ExternalProfile[]

  // NYTT: affärshändelser (deals) där kunden är säljare eller köpare
  dealsAsSeller Deal[] @relation("CustomerDealsAsSeller")
  dealsAsBuyer  Deal[] @relation("CustomerDealsAsBuyer")
}

/**
 * Transaktioner kopplade till kund (valfritt att koppla rating/rapport hit).
 */
model Transaction {
  id          String    @id @default(uuid())
  customerId  String
  amount      Decimal?  @db.Decimal(12, 2)
  currency    String?   @default("SEK")
  occurredAt  DateTime?
  externalRef String?
  evidenceUrl String?

  ratings     Rating[]
  reports     Report[]
  customer    Customer  @relation(fields: [customerId], references: [id])

  @@index([customerId])
}

/**
 * Enskilt betyg.
 */
model Rating {
  id            String  @id @default(uuid())
  customerId    String
  transactionId String?

  // NYTT: koppling till affärshändelse (Deal)
  dealId        String?

  // Betyg 1–5
  score Int

  // NYTT: varifrån detta betyg kommer (Blocket, Tradera, osv)
  ratingSource RatingSource @default(OTHER)

  // Kommentar (från formulärets kommentarsfält)
  text String?

  // Ditt namn/e-post (från "Ditt namn/mejl")
  raterName  String?
  raterEmail String? // Om användaren skriver in e-post

  // Verifierings-ID (t.ex. ORDER-123)
  verificationId String?

  // Historiskt fält – lämnas kvar för bakåtkomp.
  proofRef String?

  // Om kryssrutan "Rapportera misstänkt bedrägeri" var ikryssad
  reportedSuspectedFraud Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  customer    Customer     @relation(fields: [customerId], references: [id])
  transaction Transaction? @relation(fields: [transactionId], references: [id])

  // NYTT: relation till Deal
  deal        Deal?        @relation(fields: [dealId], references: [id])

  // En rating kan ha 0..n rapporter kopplade
  reports Report[]

  @@index([customerId])
  @@index([transactionId])
  @@index([dealId])
  @@index([createdAt])
}

/**
 * Sammanvägd poäng (framtida).
 */
model Score {
  customerId String   @id
  trustScore Int
  breakdown  Json
  updatedAt  DateTime @default(now())
  customer   Customer @relation(fields: [customerId], references: [id])
}

/**
 * Rapport om misstänkt bedrägeri/avvikelse.
 */
model Report {
  id String @id @default(uuid())

  // Vem rapporten gäller (den som blev betygsatt)
  reportedCustomerId String

  // Kopplingar (valfria) om rapporten kommer ihop med viss transaktion/betyg
  transactionId String?
  ratingId      String?

  // Typ av problem (från "Typ av problem")
  reason ReportReason

  // Beskrivning (från "Beskrivning")
  details String?

  // Bevislänk (från "Bevislänk")
  evidenceUrl String?

  // Verifierings-ID (kan speglas från rating vid behov)
  verificationId String?

  // Tidpunkt då händelsen inträffade (från datetime-local)
  occurredAt DateTime?

  // Belopp + valuta (default SEK)
  amount   Decimal? @db.Decimal(12, 2)
  currency String?  @default("SEK")

  // Länk till motpart/annons/profil
  counterpartyLink String?

  // Samtycke att uppgifterna är korrekta
  reporterConsent Boolean? @default(false)

  status    ReportStatus @default(OPEN)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  rating           Rating?      @relation(fields: [ratingId], references: [id])
  reportedCustomer Customer     @relation("CustomerReports", fields: [reportedCustomerId], references: [id])
  transaction      Transaction? @relation(fields: [transactionId], references: [id])

  // Bilagor (0–3 st rekommenderas i frontend)
  files ReportFile[]

  @@index([reportedCustomerId])
  @@index([transactionId])
  @@index([ratingId])
  @@index([createdAt])
}

/**
 * Bilagor som hör till en Report.
 */
model ReportFile {
  id        String   @id @default(uuid())
  reportId  String
  name      String
  mimeType  String
  size      Int
  data      Bytes
  createdAt DateTime @default(now())

  report    Report   @relation(fields: [reportId], references: [id], onDelete: Cascade)

  @@index([reportId])
}

/**
 * Enkel användarmodell (admin – ej kopplad till kundlogin just nu)
 */
model User {
  id    String @id @default(uuid())
  email String @unique
  role  String @default("admin")
}

/**
 * Externa profiler (Blocket, Tradera, eBay m.fl.)
 */
model ExternalProfile {
  id           String               @id @default(uuid())
  customerId   String
  customer     Customer             @relation(fields: [customerId], references: [id])

  platform     ExternalPlatform
  username     String

  // Generellt extern-id (t.ex. Tradera userId)
  externalUserId       String?

  // (Legacy/generellt) - kan användas för enklare tokens, men för eBay använder vi fälten nedan
  authToken            String?
  authTokenExpiresAt   DateTime?

  // ✅ NYTT: Krypterade OAuth-tokens (eBay nu, men kan användas även för andra plattformar)
  accessTokenEnc       String?
  refreshTokenEnc      String?
  accessTokenExpiresAt DateTime?
  refreshTokenExpiresAt DateTime?
  scopes               String?
  tokenType            String?

  // Rå profil-data från extern plattform (t.ex. feedback, ratings, osv.)
  profileJson          Json?

  // Alternativ C: vi kan lagra ett krypterat lösenord + cookies (t.ex. för Blocket-scrape)
  encryptedPassword    String?
  cookiesJson          Json?

  status       ExternalProfileStatus @default(ACTIVE)

  lastSyncedAt DateTime?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  listings       Listing[]
  traderaOrders  TraderaOrder[]

  @@index([customerId])
  @@index([platform, username])
}

/**
 * Annons/snapshot från extern plattform (t.ex. Blocket-annons)
 */
model Listing {
  id                String          @id @default(uuid())
  externalProfileId String
  externalProfile   ExternalProfile @relation(fields: [externalProfileId], references: [id])

  externalListingId String
  title             String
  price             Int?
  currency          String?        @default("SEK")
  status            ListingStatus

  url               String?
  firstSeenAt       DateTime       @default(now())
  lastSeenAt        DateTime       @default(now())

  deals             Deal[]

  @@index([externalProfileId])
  @@index([externalListingId])
}

/**
 * Affärshändelse (Deal) – underlag för omdömen
 */
model Deal {
  id        String     @id @default(uuid())

  listingId String?
  listing   Listing?   @relation(fields: [listingId], references: [id])

  sellerId  String
  seller    Customer   @relation("CustomerDealsAsSeller", fields: [sellerId], references: [id])

  buyerId   String?
  buyer     Customer?  @relation("CustomerDealsAsBuyer", fields: [buyerId], references: [id])

  source    DealSource @default(BLOCKET_SCRAPE)
  status    DealStatus @default(PENDING_RATING)

  blocketTitle String?
  blocketPrice Int?

  completedAt  DateTime?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now())

  ratings Rating[]

  @@index([sellerId])
  @@index([buyerId])
  @@index([listingId])
  @@index([createdAt])
}

/**
 * TraderaOrder – avslutade affärer från Tradera, kopplade till ExternalProfile (TRADERA)
 */
model TraderaOrder {
  id                String          @id @default(uuid())
  externalProfileId String
  externalProfile   ExternalProfile @relation(fields: [externalProfileId], references: [id])

  traderaOrderId    String
  traderaItemId     String?
  title             String

  amount            Decimal? @db.Decimal(12, 2)
  currency          String?  @default("SEK")

  role              TraderaOrderRole @default(SELLER)

  counterpartyAlias String?
  counterpartyEmail String?

  completedAt       DateTime?

  rawJson           Json?

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([externalProfileId])
  @@index([traderaOrderId])
  @@index([completedAt])
}

/**
 * Enum-typer
 */

enum TraderaOrderRole {
  BUYER
  SELLER
}

enum ReportReason {
  FRAUD
  IMPERSONATION
  NON_DELIVERY
  COUNTERFEIT
  PAYMENT_ABUSE
  OTHER
}

enum ReportStatus {
  OPEN
  UNDER_REVIEW
  RESOLVED
  REJECTED
}

// Externa plattformar
enum ExternalPlatform {
  BLOCKET
  TRADERA
  EBAY
}

enum ExternalProfileStatus {
  ACTIVE
  DISABLED
  ERROR
}

enum ListingStatus {
  ACTIVE
  SOLD
  REMOVED
}

enum DealStatus {
  PENDING_RATING
  RATED
  FLAGGED
}

enum DealSource {
  BLOCKET_SCRAPE
  MANUAL
  PARTNER_API
}

enum RatingSource {
  BLOCKET
  TRADERA
  AIRBNB
  HUSKNUTEN
  TIPTAP
  HUSKNUTEN_TIPTAP
  OTHER
}

model AgentConversation {
  id           String        @id @default(cuid())
  customerId   String?
  customer     Customer?     @relation(fields: [customerId], references: [id])
  title        String?
  systemPrompt String?       @db.Text

  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  messages     AgentMessage[]

  @@index([customerId])
  @@index([createdAt])
}

model AgentMessage {
  id              String            @id @default(cuid())
  conversationId  String
  conversation    AgentConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  role            String            // "user" | "assistant"
  content         String            @db.Text
  model           String?
  promptTokens    Int?
  completionTokens Int?
  totalTokens     Int?

  createdAt       DateTime          @default(now())

  @@index([conversationId])
  @@index([createdAt])
}
