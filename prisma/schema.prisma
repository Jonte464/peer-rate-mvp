// prisma/schema.prisma 
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * Kunder/användare (registrera dig-formuläret)
 */
model Customer {
  id             String  @id @default(uuid())
  subjectRef     String  @unique // används som "konto-id", vi sätter detta = email (lowercase)
  fullName       String?
  personalNumber String? @unique
  email          String? @unique
  phone          String?
  addressStreet  String?
  addressZip     String?
  addressCity    String?
  country        String?

  // NYTT: lösenord (hashat, aldrig klartext)
  passwordHash String?

  // NYTT: samtycke till inhämtning från tredje part
  thirdPartyConsent Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  ratings       Rating[]
  reports       Report[]      @relation("CustomerReports")
  score         Score?
  transactions  Transaction[]
  termsAccepted Boolean       @default(false)

  // NYTT: externa profiler (Blocket, Tradera m.fl.)
  externalProfiles ExternalProfile[]

  // NYTT: affärshändelser (deals) där kunden är säljare eller köpare
  dealsAsSeller      Deal[]              @relation("CustomerDealsAsSeller")
  dealsAsBuyer       Deal[]              @relation("CustomerDealsAsBuyer")
  agentConversations AgentConversation[]
}

/**
 * Transaktioner kopplade till kund (valfritt att koppla rating/rapport hit).
 */
model Transaction {
  id          String    @id @default(uuid())
  customerId  String
  amount      Decimal?  @db.Decimal(12, 2)
  currency    String?   @default("SEK")
  occurredAt  DateTime?
  externalRef String?
  evidenceUrl String?

  ratings  Rating[]
  reports  Report[]
  customer Customer @relation(fields: [customerId], references: [id])

  @@index([customerId])
}

/**
 * Enskilt betyg.
 */
model Rating {
  id            String  @id @default(uuid())
  customerId    String
  transactionId String?

  // ✅ koppling till affärshändelse (Deal)
  dealId String?

  // Betyg 1–5
  score Int

  // varifrån detta betyg kommer (Blocket, Tradera, osv)
  ratingSource RatingSource @default(OTHER)

  // Kommentar (från formulärets kommentarsfält)
  text String?

  // Ditt namn/e-post (från "Ditt namn/mejl")
  raterName  String?
  raterEmail String? // Om användaren skriver in e-post

  // Verifierings-ID (t.ex. ORDER-123) (legacy-ish)
  verificationId String?

  // Historiskt fält – lämnas kvar för bakåtkomp.
  proofRef String?

  // Om kryssrutan "Rapportera misstänkt bedrägeri" var ikryssad
  reportedSuspectedFraud Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  customer    Customer     @relation(fields: [customerId], references: [id])
  transaction Transaction? @relation(fields: [transactionId], references: [id])

  // ✅ relation till Deal
  deal Deal? @relation(fields: [dealId], references: [id])

  // En rating kan ha 0..n rapporter kopplade
  reports Report[]

  // ✅ hindra dubbla omdömen för samma affär (per rater)
  @@unique([customerId, ratingSource, proofRef, raterName])
  @@index([customerId])
  @@index([transactionId])
  @@index([dealId])
  @@index([createdAt])
}

/**
 * Sammanvägd poäng (framtida).
 */
model Score {
  customerId String   @id
  trustScore Int
  breakdown  Json
  updatedAt  DateTime @default(now())
  customer   Customer @relation(fields: [customerId], references: [id])
}

/**
 * Rapport om misstänkt bedrägeri/avvikelse.
 */
model Report {
  id String @id @default(uuid())

  // Vem rapporten gäller (den som blev betygsatt)
  reportedCustomerId String

  // Kopplingar (valfria) om rapporten kommer ihop med viss transaktion/betyg
  transactionId String?
  ratingId      String?

  // Typ av problem (från "Typ av problem")
  reason ReportReason

  // Beskrivning (från "Beskrivning")
  details String?

  // Bevislänk (från "Bevislänk")
  evidenceUrl String?

  // Verifierings-ID (kan speglas från rating vid behov)
  verificationId String?

  // Tidpunkt då händelsen inträffade (från datetime-local)
  occurredAt DateTime?

  // Belopp + valuta (default SEK)
  amount   Decimal? @db.Decimal(12, 2)
  currency String?  @default("SEK")

  // Länk till motpart/annons/profil
  counterpartyLink String?

  // Samtycke att uppgifterna är korrekta
  reporterConsent Boolean? @default(false)

  status    ReportStatus @default(OPEN)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  rating           Rating?      @relation(fields: [ratingId], references: [id])
  reportedCustomer Customer     @relation("CustomerReports", fields: [reportedCustomerId], references: [id])
  transaction      Transaction? @relation(fields: [transactionId], references: [id])

  // Bilagor (0–3 st rekommenderas i frontend)
  files ReportFile[]

  @@index([reportedCustomerId])
  @@index([transactionId])
  @@index([ratingId])
  @@index([createdAt])
}

/**
 * Bilagor som hör till en Report.
 */
model ReportFile {
  id        String   @id @default(uuid())
  reportId  String
  name      String
  mimeType  String
  size      Int
  data      Bytes
  createdAt DateTime @default(now())

  report Report @relation(fields: [reportId], references: [id], onDelete: Cascade)

  @@index([reportId])
}

/**
 * Enkel användarmodell (admin – ej kopplad till kundlogin just nu)
 */
model User {
  id    String @id @default(uuid())
  email String @unique
  role  String @default("admin")
}

/**
 * Externa profiler (Blocket, Tradera, eBay m.fl.)
 */
model ExternalProfile {
  id         String   @id @default(uuid())
  customerId String
  customer   Customer @relation(fields: [customerId], references: [id])

  platform ExternalPlatform
  username String

  // Generellt extern-id (t.ex. Tradera userId)
  externalUserId String?

  authToken          String?
  authTokenExpiresAt DateTime?

  accessTokenEnc        String?
  refreshTokenEnc       String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scopes                String?
  tokenType             String?

  profileJson Json?

  encryptedPassword String?
  cookiesJson       Json?

  status ExternalProfileStatus @default(ACTIVE)

  lastSyncedAt DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  listings      Listing[]
  traderaOrders TraderaOrder[]

  @@index([customerId])
  @@index([platform, username])
}

/**
 * Annons/snapshot från extern plattform (t.ex. Blocket-annons)
 */
model Listing {
  id                String          @id @default(uuid())
  externalProfileId String
  externalProfile   ExternalProfile @relation(fields: [externalProfileId], references: [id])

  externalListingId String
  title             String
  price             Int?
  currency          String?       @default("SEK")
  status            ListingStatus

  url         String?
  firstSeenAt DateTime @default(now())
  lastSeenAt  DateTime @default(now())

  deals Deal[]

  @@index([externalProfileId])
  @@index([externalListingId])
}

/**
 * ✅ Affärshändelse (Deal) – underlag för omdömen
 * Nu utökad så den kan representera verifierade extension-deals (t.ex. Tradera)
 */
model Deal {
  id String @id @default(uuid())

  // Koppling mot Listing (Blocket-scrape use-case)
  listingId String?
  listing   Listing? @relation(fields: [listingId], references: [id])

  // Krav i nuvarande modell: vi sätter default till "den som blir betygsatt" för extension-flödet
  sellerId String
  seller   Customer @relation("CustomerDealsAsSeller", fields: [sellerId], references: [id])

  buyerId String?
  buyer   Customer? @relation("CustomerDealsAsBuyer", fields: [buyerId], references: [id])

  // ✅ Plattform för dealen (TRADERA/BLOCKET/EBAY)
  platform ExternalPlatform @default(BLOCKET)

  source DealSource @default(BLOCKET_SCRAPE)
  status DealStatus @default(PENDING_RATING)

  // Legacy blocket-fält
  blocketTitle String?
  blocketPrice Int?

  // ✅ Extension/partner-deal fält
  externalProofRef String?  // t.ex. Tradera orderId
  externalItemId   String?  // t.ex. Tradera itemId
  externalPageUrl  String?  // URL till källsidan
  title            String?
  amount           Decimal? @db.Decimal(12, 2)
  currency         String?  @default("SEK")

  completedAt DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  ratings Rating[]

  // ✅ Unik affär per plattform + proofRef/orderId
  @@unique([platform, externalProofRef])
  @@index([sellerId])
  @@index([buyerId])
  @@index([listingId])
  @@index([platform])
  @@index([externalProofRef])
  @@index([createdAt])
}

/**
 * TraderaOrder – avslutade affärer från Tradera, kopplade till ExternalProfile (TRADERA)
 */
model TraderaOrder {
  id                String          @id @default(uuid())
  externalProfileId String
  externalProfile   ExternalProfile @relation(fields: [externalProfileId], references: [id])

  traderaOrderId String
  traderaItemId  String?
  title          String

  amount   Decimal? @db.Decimal(12, 2)
  currency String?  @default("SEK")

  role TraderaOrderRole @default(SELLER)

  counterpartyAlias String?
  counterpartyEmail String?

  completedAt DateTime?

  rawJson Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([externalProfileId])
  @@index([traderaOrderId])
  @@index([completedAt])
}

/**
 * Enum-typer
 */
enum TraderaOrderRole {
  BUYER
  SELLER
}

enum ReportReason {
  FRAUD
  IMPERSONATION
  NON_DELIVERY
  COUNTERFEIT
  PAYMENT_ABUSE
  OTHER
}

enum ReportStatus {
  OPEN
  UNDER_REVIEW
  RESOLVED
  REJECTED
}

enum ExternalPlatform {
  BLOCKET
  TRADERA
  EBAY
}

enum ExternalProfileStatus {
  ACTIVE
  DISABLED
  ERROR
}

enum ListingStatus {
  ACTIVE
  SOLD
  REMOVED
}

enum DealStatus {
  PENDING_RATING
  RATED
  FLAGGED
}

enum DealSource {
  BLOCKET_SCRAPE
  TRADERA_EXTENSION
  MANUAL
  PARTNER_API
}

enum RatingSource {
  BLOCKET
  TRADERA
  AIRBNB
  HUSKNUTEN
  TIPTAP
  HUSKNUTEN_TIPTAP
  OTHER
}

model AgentConversation {
  id           String    @id @default(cuid())
  customerId   String?
  customer     Customer? @relation(fields: [customerId], references: [id])
  title        String?
  systemPrompt String?   @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  messages AgentMessage[]

  @@index([customerId])
  @@index([createdAt])
}

model AgentMessage {
  id             String            @id @default(cuid())
  conversationId String
  conversation   AgentConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  role             String
  content          String @db.Text
  model            String?
  promptTokens     Int?
  completionTokens Int?
  totalTokens      Int?

  createdAt DateTime @default(now())

  @@index([conversationId])
  @@index([createdAt])
}
